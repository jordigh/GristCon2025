services:
  grist:
    image: gristlabs/grist:latest
    environment:
      # Forces Grist to only use a single team called 'Example'
      GRIST_SINGLE_ORG: my-grist-team   # alternatively, GRIST_ORG_IN_PATH: "true" for multi-team operation
      # Force users to login (disable anonymous access)
      GRIST_FORCE_LOGIN: true
      # Default email for the "Admin" account
      GRIST_DEFAULT_EMAIL: ${GRIST_DEFAULT_EMAIL}

      # Postgres database setup
      TYPEORM_DATABASE: grist
      TYPEORM_USERNAME: grist
      TYPEORM_HOST: grist-db
      TYPEORM_LOGGING: false
      TYPEORM_PASSWORD: ${DATABASE_PASSWORD}
      TYPEORM_PORT: 5432
      TYPEORM_TYPE: postgres

      # Redis setup
      REDIS_URL: redis://grist-redis

      # MinIO setup. This requires the bucket set up on the MinIO instance with versioning enabled.
      GRIST_DOCS_MINIO_ACCESS_KEY: grist
      GRIST_DOCS_MINIO_SECRET_KEY: ${MINIO_PASSWORD}
      GRIST_DOCS_MINIO_USE_SSL: 0
      GRIST_DOCS_MINIO_BUCKET: grist-docs
      GRIST_DOCS_MINIO_ENDPOINT: grist-minio
      GRIST_DOCS_MINIO_PORT: 9000

      # External Storage for attachments
      GRIST_EXTERNAL_ATTACHMENTS_MODE: "snapshots"

      GRIST_OIDC_SP_HOST: http://localhost:8484
      GRIST_OIDC_IDP_ISSUER: https://${GRIST_HOST}/keycloak/realms/myrealm
      GRIST_OIDC_IDP_SCOPES: openid profile email

      # the ID you chose for the Keycloak client
      GRIST_OIDC_IDP_CLIENT_ID: gristclient

      # the client secret generated by Keycloak retrieved earlier
      GRIST_OIDC_IDP_CLIENT_SECRET: ${OIDC_CLIENT_SECRET}

      GRIST_OIDC_SP_EXTRA_PROPS_TO_STORE: email_verified,preferred_username
    volumes:
      # Where to store persistent data, such as documents.
      - ${PERSIST_DIR}/grist:/persist
    labels:
      - "traefik.http.services.grist.loadbalancer.server.port=8484"
      - "traefik.http.routers.grist.rule=Host(`${GRIST_HOST}`)"
      - "traefik.http.routers.grist.tls.certresolver=letsencrypt"
    depends_on:
      grist-db:
        condition: service_started
      grist-redis:
        condition: service_started
      grist-minio:
        condition: service_started
      minio-setup:
        condition: service_completed_successfully
      kc_postgresql:
        condition: service_started
      keycloak:
        condition: service_healthy

    develop:
      watch:
      - action: sync+restart
        path: ../../_build
        target: /grist/_build


  grist-db:
    image: postgres:alpine
    environment:
        POSTGRES_DB: grist
        POSTGRES_USER: grist
        POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
    ports:
      - "5434:5432"
    volumes:
      - ${PERSIST_DIR}/postgres:/var/lib/postgresql/data

  grist-redis:
    image: redis:alpine
    volumes:
      - ${PERSIST_DIR}/redis:/data

  grist-minio:
    image: minio/minio:latest
    environment:
      MINIO_ROOT_USER: grist
      MINIO_ROOT_PASSWORD: ${MINIO_PASSWORD}
    volumes:
      - ${PERSIST_DIR}/minio:/data
    command:
      server /data --console-address=":9001"

  # This sets up the buckets required in MinIO. It is only needed to make this example work.
  # It isn't necessary for deployment and can be safely removed.
  minio-setup:
    image: minio/mc
    environment:
      MINIO_PASSWORD: ${MINIO_PASSWORD}
    depends_on:
      grist-minio:
        condition: service_started
    restart: on-failure
    entrypoint: >
      /bin/sh -c "
      /usr/bin/mc alias set myminio http://grist-minio:9000 grist '$MINIO_PASSWORD';
      /usr/bin/mc mb myminio/grist-docs;
      /usr/bin/mc anonymous set public myminio/grist-docs;
      /usr/bin/mc version enable myminio/grist-docs;
      "

  kc_postgresql:
    image: postgres:alpine
    ports:
      - "5433:5432"
    environment:
      # Postgresql db container configuration
      - POSTGRES_DB=keycloak
      - POSTGRES_USER=grist
      - POSTGRES_PASSWORD=pass

      # App database configuration
      - DB_HOST=kc_postgresql
      - DB_NAME=keycloak
      - DB_USER=grist
      - DB_PASSWORD=pass
      - DB_PORT=5433

  keycloak:
    image: quay.io/keycloak/keycloak:26.2.0
    volumes:
      - ${PERSIST_DIR}/keycloak/auth:/opt/keycloak/data/import
    command:
      - start
      - --import-realm
    environment:
      KC_BOOTSTRAP_ADMIN_USERNAME: admin
      KC_BOOTSTRAP_ADMIN_PASSWORD: admin
      KC_DB: postgres
      KC_DB_URL_HOST: kc_postgresql
      KC_DB_URL_DATABASE: keycloak
      KC_DB_PASSWORD: pass
      KC_DB_USERNAME: grist
      KC_DB_SCHEMA: public

      KC_HOSTNAME: ${GRIST_HOST}
      KC_HTTP_ENABLED: true
      KC_PROXY_HEADERS: xforwarded
      KC_HTTP_RELATIVE_PATH: /keycloak
    ports:
      - "8080:8080"
      - "8083:8083"
      - "9080:9000"
    depends_on:
      - kc_postgresql
    healthcheck:
      # This healthcheck is a way to wait for Keycloak to be ready. It only checks Keycloak's health once since healthchecks in KC are sometimes weird : https://github.com/keycloak/keycloak/discussions/10575
      test: ["CMD-SHELL", "if [ ! -f /tmp/health.txt ]; then touch /tmp/health.txt && exec 3<>/dev/tcp/127.0.0.1/9000;echo -e 'GET /health/ready HTTP/1.1\r\nhost: http://localhost\r\nConnection: close\r\n\r\n' >&3;if [ $? -eq 0 ]; then echo 'Healthcheck Successful';exit 0;else echo 'Healthcheck Failed';exit 1;fi; else echo \"Healthcheck already executed\"; fi"]
    labels:
      - "traefik.http.routers.keycloak.rule=Host(`${GRIST_HOST}`) && PathPrefix(`/keycloak`)"
      - "traefik.http.routers.keycloak.entrypoints=websecure"
      - "traefik.http.routers.keycloak.tls.certresolver=letsencrypt"
      - "traefik.http.services.keycloak.loadbalancer.server.port=8080"

  traefik:
    image: traefik:latest
    environment:
      TRAEFIK_CERTIFICATESRESOLVERS_letsencrypt_ACME_EMAIL: ${GRIST_DEFAULT_EMAIL}
    ports:
      # HTTP Ports
      - "80:80"
      - "443:443"
      # The Web UI (enabled by --api.insecure=true)
      # - "8080:8080"
    volumes:
      # Set the config file for traefik - this is loaded automatically.
      - ./configs/traefik-config.yml:/etc/traefik/traefik.yml
      # Certificate location, if automatic certificate setup is enabled.
      - ./configs/acme:/acme
      # Traefik needs docker access when configured via docker labels.
      - /var/run/docker.sock:/var/run/docker.sock
    depends_on:
      - grist
